<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShiYC的博客</title>
  
  
  <link href="https://faketerrible.github.io/atom.xml" rel="self"/>
  
  <link href="https://faketerrible.github.io/"/>
  <updated>2021-05-31T09:46:19.563Z</updated>
  <id>https://faketerrible.github.io/</id>
  
  <author>
    <name>ShiYC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>4的幂</title>
    <link href="https://faketerrible.github.io/2021/05/31/4%E7%9A%84%E5%B9%82/"/>
    <id>https://faketerrible.github.io/2021/05/31/4%E7%9A%84%E5%B9%82/</id>
    <published>2021-05-31T09:01:01.000Z</published>
    <updated>2021-05-31T09:46:19.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整数 n 是 4 的幂次方需满足：存在整数 x 使得 <code>n == 4^x</code></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 16</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p><code>-231 &lt;= n &lt;= 231 - 1</code> </p><p><strong>进阶：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你能不使用循环或者递归来完成本题吗？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;昨天是 2 的幂，今天是 4 的幂。思路其实是相似的。</p><p><strong><a href="/2021/05/30/2%E7%9A%84%E5%B9%82/#more"> 2 的幂</a></strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 的幂是 2 的幂， 4 的幂的二进制位数不是偶数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，根据 2 的幂的思路，可以写出下面的代码。</p><p><strong>代码一</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var isPowerOfFour = function(n) &#123;</span><br><span class="line">    if(n === 0) return false;</span><br><span class="line">    if(n === 1) return true;</span><br><span class="line">    if(n % 4 != 0) return false;</span><br><span class="line">    return isPowerOfFour(n / 4);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码二</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var isPowerOfFour = function(n) &#123;</span><br><span class="line">    if(n === 0) return false;</span><br><span class="line">    var ans = n.toString(4);</span><br><span class="line">    for(let i = 1; i &lt; ans.length; i++)&#123;</span><br><span class="line">        if(ans[i] != &#x27;0&#x27;)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans[0] === &#x27;1&#x27;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码三</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var isPowerOfFour = function(n) &#123;</span><br><span class="line">    return n &gt; 0 &amp;&amp; (n &amp; (n-1)) === 0 &amp;&amp; (n &amp; 0xaaaaaaaa) === 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码四</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var isPowerOfFour = function(n) &#123;</span><br><span class="line">    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) === 0 &amp;&amp; n % 3 === 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述四个代码里，第一种使用了递归。思路也很简单，只有三种条件，当 n 等于 0 时， 返回<code>false</code>，当 n 等于 1 时，返回<code>true</code>,当 n 取 4 的余数非等于 0 时，不是 4 的幂，返回 <code>false</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个代码，思路是考虑跟二进制相仿的情况， 4 的幂的四进制数的最高位是 1 ，其他位上是 0。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三个，思路是考虑二进制下的 4 的幂的数字的规律。因为 4 的幂的二进制位数是奇数，所以最后加上一个特殊的判断 <code>n &amp; 0xaaaaaaaa === 0</code> 。其中 a 在十六进制中表示 10 ，二进制数为 <code>1010</code> 。所以 4 的幂的数字与 <code>0xaaaaaaaa</code> 相 <code>&amp;</code>，结果为<code>0</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一种利用的是取模性质， 4 的幂除以 3 的余数必然是 1 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;给定一个整数，写一个函数来判</summary>
      
    
    
    
    <category term="算法" scheme="https://faketerrible.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="javascript" scheme="https://faketerrible.github.io/tags/javascript/"/>
    
    <category term="二进制" scheme="https://faketerrible.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>字符串的扩展</title>
    <link href="https://faketerrible.github.io/2021/05/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://faketerrible.github.io/2021/05/30/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</id>
    <published>2021-05-30T14:48:27.000Z</published>
    <updated>2021-05-30T15:13:17.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 <code>Unicode</code> 表示法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ES6</code> 允许采用 <code>\uxxxx</code> 形式表示一个字符。</p><blockquote><p>这种表示法只限于码点在 <code>\u0000~\uFFFF</code> 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JavaScript</code> 共有 6 种方法可以表示一个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\z&#x27;</span> === <span class="string">&#x27;z&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u&#123;7A&#125;&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串可以被 <code>for...of</code> 循环遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了遍历字符串，这个遍历器最大的优点是可以识别大于 <code>0xFFFF</code> 的码点，传统的 <code>for</code> 循环无法识别这样的码点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot; &quot;</span></span><br><span class="line"><span class="comment">// &quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br></pre></td></tr></table></figure><h3 id="直接输入-U-2028-和-U-2029"><a href="#直接输入-U-2028-和-U-2029" class="headerlink" title="直接输入 U+2028 和 U+2029"></a>直接输入 <code>U+2028</code> 和 <code>U+2029</code></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。</p><ul><li>U+005C：反斜杠（reverse solidus)</li><li>U+000D：回车（carriage return）</li><li>U+2028：行分隔符（line separator）</li><li>U+2029：段分隔符（paragraph separator）</li><li>U+000A：换行符（line feed）</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PS = <span class="built_in">eval</span>(<span class="string">&quot;&#x27;\u2029&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。</p></blockquote><h3 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify() 的改造"></a><code>JSON.stringify()</code> 的改造</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="comment">// &quot;&quot;\\uD834&quot;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">&#x27;\uDF06\uD834&#x27;</span>) <span class="comment">// &quot;&quot;\\udf06\\ud834&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES6 引入了模板字符串。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果大括号中的值不是字符串，将按照一般的规则转为字符串。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果模板字符串中的变量没有声明，将报错。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果大括号内部是一个字符串，将会原样输出。模板字符串甚至还能嵌套。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要引用模板字符串本身，在需要时执行，可以写成函数。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;字符的-Unicode-表示法&quot;&gt;&lt;a href=&quot;#字符的-Unicode-表示法&quot; class=&quot;headerlink&quot; title=&quot;字符的 Unicode 表示法&quot;&gt;&lt;/a&gt;字符的 &lt;code&gt;Unicode&lt;/code&gt; 表示法&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;ES6&lt;/code&gt; 允许采用 &lt;code&gt;\uxxxx&lt;/code&gt; 形式表示一个字符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种表示法只限于码点在 &lt;code&gt;\u0000~\uFFFF&lt;/code&gt; 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;JavaScript&lt;/code&gt; 共有 6 种方法可以表示一个字符。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#x27;\z&amp;#x27;&lt;/span&gt; === &lt;span class=&quot;string&quot;&gt;&amp;#x27;z&amp;#x27;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#x27;\172&amp;#x27;&lt;/span&gt; === &lt;span class=&quot;string&quot;&gt;&amp;#x27;z&amp;#x27;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#x27;\x7A&amp;#x27;&lt;/span&gt; === &lt;span class=&quot;string&quot;&gt;&amp;#x27;z&amp;#x27;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#x27;\u007A&amp;#x27;&lt;/span&gt; === &lt;span class=&quot;string&quot;&gt;&amp;#x27;z&amp;#x27;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&amp;#x27;\u&amp;#123;7A&amp;#125;&amp;#x27;&lt;/span&gt; === &lt;span class=&quot;string&quot;&gt;&amp;#x27;z&amp;#x27;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="前端" scheme="https://faketerrible.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://faketerrible.github.io/tags/javascript/"/>
    
    <category term="ES6" scheme="https://faketerrible.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>2的幂</title>
    <link href="https://faketerrible.github.io/2021/05/30/2%E7%9A%84%E5%B9%82/"/>
    <id>https://faketerrible.github.io/2021/05/30/2%E7%9A%84%E5%B9%82/</id>
    <published>2021-05-30T05:26:49.000Z</published>
    <updated>2021-05-31T09:11:26.392Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：20 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 16</span><br><span class="line">输出：true</span><br><span class="line">解释：24 = 16</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= n &lt;= 231 - 1</code></li></ul><p> </p><blockquote><p>进阶：你能够不使用循环/递归解决此问题吗？</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目很好理解，只要判断 n 是否是 2 的幂即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，<code>-231 &lt;= n &lt;= 231 - 1</code>，也就是说 n 有可能是负数和 0 ，需要对 n 进行判断。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，想到的是将 n 进行除法操作，只要 n 取 2 的余数非等于 0 ，就直接返回 <code>false</code>。如果是 2 的幂，则可以进行到 <code>n === 1</code>。</p><p><strong>代码如下：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfTwo = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isPowerOfTwo(n/<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;涉及到 2 ，很容易联想到二进制。想到二进制，很容易得到， 2 的幂就是最高位是 1 ，其他位为 0 。</p><p><strong>代码如下：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfTwo = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码就一行，可以通过。代码中<code>(n &amp; (n - 1)) === 0</code>表示的是<code>n</code>与<code>n-1</code>相与，即<code>n</code>的二进制的每一位与<code>n-1</code>的二进制的每一位进行<code>&amp;</code>运算。<code>1</code>和<code>0</code>进行<code>&amp;</code>运算，结果是 0 ,<code>1</code>和<code>1</code>进行<code>&amp;</code>运算结果为<code>1</code>，其他结果为 0 。因为 2 的幂的二进制数最高位是 1 ，其他位为 0 ，所以 n 和 n - 1 的结果为 0 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是否有一个数可以对所有的 2 的幂取余呢？</p><p><strong>代码如下：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfTwo = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> BIG = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (BIG % n) === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一种较为取巧的做法。在题目给定的 32 位有符号整数的范围内，最大的 2 的幂为2^30=10737418242 我们只需要判断 n 是否是 2^30 的约数即可。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://faketerrible.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="javascript" scheme="https://faketerrible.github.io/tags/javascript/"/>
    
    <category term="二进制" scheme="https://faketerrible.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>变量的解构赋值</title>
    <link href="https://faketerrible.github.io/2021/05/26/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://faketerrible.github.io/2021/05/26/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</id>
    <published>2021-05-26T12:01:18.000Z</published>
    <updated>2021-05-26T13:06:01.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">结构赋值</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解构赋值语法是一种 <code>Javascript</code> 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。</p><h3 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ES6</code> 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ES6</code> 允许写成下面这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><span id="more"></span><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解构不成功，变量的值就等于undefined。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>解构赋值允许指定默认值。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</p></blockquote><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解构不仅可以用于数组，还可以用于对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与数组一样，解构也可以用于嵌套结构的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br><span class="line">p <span class="comment">// [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><blockquote><p>注意，对象的解构赋值可以取到继承的属性。</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对象的解构也可以指定默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// &quot;Something went wrong&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;结构赋值&quot;&gt;&lt;a href=&quot;#结构赋值&quot; class=&quot;headerlink&quot; title=&quot;结构赋值&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;结构赋值&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;解构赋值语法是一种 &lt;code&gt;Javascript&lt;/code&gt; 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。&lt;/p&gt;
&lt;h3 id=&quot;数组的结构赋值&quot;&gt;&lt;a href=&quot;#数组的结构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的结构赋值&quot;&gt;&lt;/a&gt;数组的结构赋值&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;ES6&lt;/code&gt; 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;ES6&lt;/code&gt; 允许写成下面这样:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [a, b, c] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="前端" scheme="https://faketerrible.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://faketerrible.github.io/tags/javascript/"/>
    
    <category term="ES6" scheme="https://faketerrible.github.io/tags/ES6/"/>
    
    <category term="解构赋值" scheme="https://faketerrible.github.io/tags/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>let和const命令</title>
    <link href="https://faketerrible.github.io/2021/05/25/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <id>https://faketerrible.github.io/2021/05/25/let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</id>
    <published>2021-05-25T11:33:54.000Z</published>
    <updated>2021-05-25T12:50:33.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自从学习了<code>javascript</code>之后，一直想要继续夯实基础。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后来机缘巧合，得到了能在线阅读的<a href="https://es6.ruanyifeng.com/">ES6入门教程</a>。一直没有记录笔记，或者只是当做资料参考。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;趁此机会，我决定要记录自己的学习以及阅读感受。</p><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a><code>let</code>命令</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>let</code>命令是<code>ES6</code>新增的命令。它的用法类似<code>var</code>，但是它声明的变量只在<code>let</code>命令所在的代码块内有效。</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError"><code>ReferenceError</code></a>（引用错误） 对象代表当一个不存在的变量被引用时发生的错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>var</code>命令会发生“变量提升”现象，<code>let</code>命令不存在变量提升。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>let</code>不允许在相同作用域内，重复声明同一个变量。</p><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a><code>const</code>命令</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI <span class="comment">// 3.14415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a>（类型错误） 对象用来表示值的类型非预期类型时发生的错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>let</code>和<code>const</code>命令，有很多相似的地方，只在声明的块级作用域内有效，存在暂时性死区，一样不可重复声明。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;自从学习了&lt;code&gt;javascript&lt;/code&gt;之后，一直想要继续夯实基础。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;后来机缘巧合，得到了能在线阅读的&lt;a href=&quot;https://es6.ruanyifeng.com/&quot;&gt;ES6入门教程&lt;/a&gt;。一直没有记录笔记，或者只是当做资料参考。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;趁此机会，我决定要记录自己的学习以及阅读感受。&lt;/p&gt;
&lt;h3 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命令&quot; class=&quot;headerlink&quot; title=&quot;let命令&quot;&gt;&lt;/a&gt;&lt;code&gt;let&lt;/code&gt;命令&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;let&lt;/code&gt;命令是&lt;code&gt;ES6&lt;/code&gt;新增的命令。它的用法类似&lt;code&gt;var&lt;/code&gt;，但是它声明的变量只在&lt;code&gt;let&lt;/code&gt;命令所在的代码块内有效。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://faketerrible.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://faketerrible.github.io/tags/javascript/"/>
    
    <category term="ES6" scheme="https://faketerrible.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>钟摆旋转</title>
    <link href="https://faketerrible.github.io/2021/05/24/%E9%92%9F%E6%91%86%E6%97%8B%E8%BD%AC/"/>
    <id>https://faketerrible.github.io/2021/05/24/%E9%92%9F%E6%91%86%E6%97%8B%E8%BD%AC/</id>
    <published>2021-05-24T10:24:52.000Z</published>
    <updated>2021-05-24T13:11:13.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一道面试题，出现在很多公司的面试题中，我也不幸中招。当时，我说出了自己的思路,但是并不准确。通过这道题，我们会学到<code>transform</code>和<code>animation</code>。</p><h3 id="简单的实现"><a href="#简单的实现" class="headerlink" title="简单的实现"></a>简单的实现</h3><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.one</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">transform-origin</span>: center top;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation</span>: test <span class="number">5s</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-timing-function</span>: linear;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-iteration-count</span>: infinite;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.line</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: <span class="number">4.5px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.ball</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="keyword">@keyframes</span> test &#123;</span></span><br><span class="line"><span class="css">            <span class="number">0%</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="number">25%</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="number">50%</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="number">75%</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="number">100%</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ball&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上述的代码中，实现了钟摆的摆动。</p><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a><code>transform</code></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">MDN文档</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要实现钟摆的旋转，就要碰到旋转的问题。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS<code>transform</code>属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>transform: rotate()</code>可以旋转我们的钟摆，但是，直接设置旋转会从中心点进行旋转。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，我们需要设置旋转的起点。<code>transform-origin</code> CSS属性让你更改一个元素变形的原点。</p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a><code>animation</code></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>animation</code> 属性是 <code>animation-name</code>，<code>animation-duration</code>, <code>animation-timing-function</code>，<code>animation-delay</code>，<code>animation-iteration-count</code>，<code>animation-direction</code>，<code>animation-fill-mode</code> 和 <code>animation-play-state</code> 属性的一个简写属性形式。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>animation-timing-function</code>属性定义CSS动画在每一动画周期中执行的节奏。从头到尾以相同的速度播放动画：<code>animation-timing-function: linear;</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>animation-iteration-count</code> CSS 属性,定义动画在结束前运行的次数,可以是1次也可以是无限循环。<code>infinite</code>无限循环播放动画。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>transform</code>和<code>animation</code>是写动画效果时常用的css属性。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是一道面试题，出现在很多公司的面试题中，我也不幸中招。当时，我说出了自己的思路,但是并不准确。通过这道题，我们会学到&lt;code&gt;transform&lt;/code&gt;和&lt;code&gt;animation&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;简单的实现&quot;&gt;&lt;a href=&quot;#简单的实现&quot; class=&quot;headerlink&quot; title=&quot;简单的实现&quot;&gt;&lt;/a&gt;简单的实现&lt;/h3&gt;</summary>
    
    
    
    <category term="前端" scheme="https://faketerrible.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="css" scheme="https://faketerrible.github.io/tags/css/"/>
    
    <category term="transform" scheme="https://faketerrible.github.io/tags/transform/"/>
    
    <category term="animation" scheme="https://faketerrible.github.io/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>深入学习节流防抖函数</title>
    <link href="https://faketerrible.github.io/2021/05/24/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    <id>https://faketerrible.github.io/2021/05/24/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/</id>
    <published>2021-05-24T01:02:39.000Z</published>
    <updated>2021-05-24T02:36:46.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><pre><code>我一直觉得节流防抖很简单，但是，在看到大佬的博客后，不得不佩服。从原理到应用的函数，作用和代码原理，简单的变复杂，复杂的变深奥，最后震撼人心。想要追上大佬，就得向大佬学习。本着比不过，就模仿学习的想法，开始了本次的学习。</code></pre><span id="more"></span><h3 id="节流定义及解读"><a href="#节流定义及解读" class="headerlink" title="节流定义及解读"></a>节流定义及解读</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数节流指的是某个函数在一定时间间隔内（例如 3 秒）只执行一次，在这 3 秒内 无视后来产生的函数调用请求，也不会延长时间间隔。3 秒间隔结束后第一次遇到新的函数调用会触发执行，然后在这新的 3 秒内依旧无视后来产生的函数调用请求，以此类推。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;防抖函数 debounce 指的是某个函数在某段时间内，无论触发了多少次回调，都只执行最后一次。假如我们设置了一个等待时间 3 秒的函数，在这 3 秒内如果遇到函数调用请求就重新计时 3 秒，直至新的 3 秒内没有函数调用请求，此时执行函数，不然就以此类推重新计时。</p><h3 id="原理及实现"><a href="#原理及实现" class="headerlink" title="原理及实现"></a>原理及实现</h3><h5 id="节流函数throttle"><a href="#节流函数throttle" class="headerlink" title="节流函数throttle"></a>节流函数<code>throttle</code></h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;函数节流非常适用于函数被频繁调用的场景，例如：<code>window.onresize()</code> 事件、<code>mousemove</code> 事件、上传进度等情况。使用 <code>throttle</code> API 很简单，那应该如何实现 <code>throttle</code> 这个函数呢？</p><p><em><strong>实现方案有以下两种：</strong></em></p><ul><li><p>第一种是用时间戳来判断是否已到执行时间，记录上次执行的时间戳，然后每次触发事件执行回调，回调中判断当前时间戳距离上次执行时间戳的间隔是否已经达到时间差（Xms） ，如果是则执行，并更新上次执行的时间戳，如此循环。</p></li><li><p>第二种方法是使用定时器，比如当 scroll 事件刚触发时，打印一个 hello world，然后设置个 1000ms 的定时器，此后每次触发 scroll 事件触发回调，如果已经存在定时器，则回调不执行方法，直到定时器触发，handler 被清除，然后重新设置定时器。</p></li></ul><p><strong>实现节流函数：</strong></p><ul><li>使用时间戳</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是需要执行的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, wait = <span class="number">50</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 上一次执行 fn 的时间</span></span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="comment">// 将当前时间和上一次执行函数的时间进行对比</span></span><br><span class="line">    <span class="comment">// 大于等待时间就把 previous 设置为当前时间并执行函数 fn</span></span><br><span class="line">    <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">      previous = now</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 throttle 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = throttle(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;fn 函数执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 每 10 毫秒执行一次 betterFn 函数，但是只有时间差大于 1000 时才会执行 fn</span></span><br><span class="line"><span class="built_in">setInterval</span>(betterFn, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li>使用定时器</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(!timeout)&#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                fn.apply(context,args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两种方法对比</strong></p><ul><li><p><strong>首次触发</strong>：使用时间戳实现时会立即执行（将previous设为0的情况）；使用定时器实现会设置定时器，wait毫秒后执行。</p></li><li><p><strong>停止触发</strong>：使用时间戳实现时，停止触发后不会再执行；使用定时器实现时，由于存在定时器，停止触发后还会执行一次。</p></li></ul><p><strong>应用场景</strong></p><ul><li>DOM 元素的拖拽功能实现（mousemove）</li><li>射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）</li><li>计算鼠标移动的距离（mousemove）</li><li>Canvas 模拟画板功能（mousemove）</li><li>搜索联想（keyup）</li><li>监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次</li></ul><h5 id="防抖函数debounce"><a href="#防抖函数debounce" class="headerlink" title="防抖函数debounce"></a>防抖函数<code>debounce</code></h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现原理就是利用定时器，函数第一次执行时设定一个定时器，之后调用时发现已经设定过定时器就清空之前的定时器，并重新设定一个新的定时器，如果存在没有被清空的定时器，当定时器计时结束后触发函数执行。</p><ul><li>实现</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 1</span></span><br><span class="line"><span class="comment">// fn 是需要防抖处理的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 将 debounce 处理结果当作函数返回</span></span><br><span class="line">    <span class="comment">// 触发事件回调时执行这个返回函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果已经设定过定时器就清空上一次的定时器</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 开始设定一个新的定时器，定时器结束后执行传入的函数 fn</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 debounce 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = debounce(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;fn 防抖执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 停止滑动 1 秒后执行函数 () =&gt; console.log(&#x27;fn 防抖执行了&#x27;)</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, betterFn)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述实现方案已经可以解决大部分使用场景了，不过想要实现第一次触发回调事件就执行 fn 有点力不从心了，这时候我们来改写下 debounce 函数，加上第一次触发立即执行的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 2</span></span><br><span class="line"><span class="comment">// immediate 表示第一次是否立即执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait = <span class="number">50</span>, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ------ 新增部分 start ------ </span></span><br><span class="line">      <span class="comment">// immediate 为 true 表示第一次触发后执行</span></span><br><span class="line">      <span class="comment">// timer 为空表示首次触发</span></span><br><span class="line">        <span class="keyword">if</span> (immediate &amp;&amp; !timer) &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// ------ 新增部分 end ------ </span></span><br><span class="line">      </span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 debounce 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = debounce(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;fn 防抖执行了&#x27;</span>), <span class="number">1000</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 第一次触发 scroll 执行一次 fn，后续只有在停止滑动 1 秒后才执行函数 fn</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, betterFn)</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次学习基本结束，但是这只是另一个开始。对于优化的学习以及 <code>underscore</code>的学习才刚开始。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;我一直觉得节流防抖很简单，但是，在看到大佬的博客后，不得不佩服。

从原理到应用的函数，作用和代码原理，简单的变复杂，复杂的变深奥，最后震撼人心。

想要追上大佬，就得向大佬学习。本着比不过，就模仿学习的想法，开始了本次的学习。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="前端" scheme="https://faketerrible.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://faketerrible.github.io/tags/javascript/"/>
    
    <category term="节流防抖函数" scheme="https://faketerrible.github.io/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>作品集</title>
    <link href="https://faketerrible.github.io/2021/05/23/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    <id>https://faketerrible.github.io/2021/05/23/%E4%BD%9C%E5%93%81%E9%9B%86/</id>
    <published>2021-05-23T12:44:41.000Z</published>
    <updated>2021-05-23T13:26:58.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作品链接地址"><a href="#作品链接地址" class="headerlink" title="作品链接地址"></a>作品链接地址</h3><p><a href="https://faketerrible.github.io/2048Game/">2048Game</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;作品链接地址&quot;&gt;&lt;a href=&quot;#作品链接地址&quot; class=&quot;headerlink&quot; title=&quot;作品链接地址&quot;&gt;&lt;/a&gt;作品链接地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://faketerrible.github.io/2048Game/&quot;&gt;204</summary>
      
    
    
    
    <category term="作品集" scheme="https://faketerrible.github.io/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
    <category term="作品集" scheme="https://faketerrible.github.io/tags/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>webpack学习一</title>
    <link href="https://faketerrible.github.io/2021/05/23/webpack%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <id>https://faketerrible.github.io/2021/05/23/webpack%E5%AD%A6%E4%B9%A0%E4%B8%80/</id>
    <published>2021-05-23T06:06:38.000Z</published>
    <updated>2021-05-23T08:37:41.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>本质上，<code>webpack</code> 是一个用于现代 <code>JavaScript</code> 应用程序的 静态模块打包工具。当 <code>webpack</code> 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 <code>bundle</code>。</p><blockquote><p> 注意：从 v4.0.0 开始，webpack 可以不用再引入一个配置文件来打包项目，然而，它仍然有着 高度可配置性，可以很好满足你的需求。</p></blockquote><h3 id="我们为什么要学习webpack"><a href="#我们为什么要学习webpack" class="headerlink" title="我们为什么要学习webpack"></a>我们为什么要学习<a href="https://webpack.docschina.org/concepts/"><code>webpack</code></a></h3><p><em><strong><code>webpack</code>的主要优势</strong></em></p><p>① 模块化开发（import，require）<br>② 预处理（Less，Sass，ES6，TypeScript……）<br>③ 主流框架脚手架支持（Vue，React，Angular）<br>④ 庞大的社区（资源丰富，降低学习成本）</p><span id="more"></span><h3 id="在开始前我们需要先理解一些核心概念："><a href="#在开始前我们需要先理解一些核心概念：" class="headerlink" title="在开始前我们需要先理解一些核心概念："></a>在开始前我们需要先理解一些<strong>核心概念</strong>：</h3><ul><li><strong>入口(entry)</strong></li></ul><p>入口起点(entry point) 指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>:<span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>输出(output)</strong></li></ul><p>output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。</p><p>webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面导入的 path 模块是什么，它是一个 <code>Node.js</code> 核心模块，用于操作文件路径。</p><ul><li><strong>loader</strong></li></ul><p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。</p><blockquote><p>注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是很有必要的，因为这可以使开发人员创建出更准确的依赖关系图。</p></blockquote><p><em><strong>在更高层面，在 webpack 的配置中，loader 有两个属性</strong></em>：</p><blockquote><ol><li>test 属性，识别出哪些文件会被转换。</li><li>use 属性，定义出在进行转换时，应该使用哪个 loader。</li></ol></blockquote><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span>&#125;],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息：</p><blockquote><p>“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先 use(使用) raw-loader 转换一下。”</p></blockquote><blockquote><p>重要的是要记住，在 webpack 配置中定义 rules 时，要定义在 <code>module.rules</code> 而不是 rules 中。为了使你便于理解，如果没有按照正确方式去做，webpack 会给出警告。</p></blockquote><blockquote><p>请记住，使用正则表达式匹配文件时，你不要为它添加引号。也就是说，<code>/\.txt$/</code> 与 <code>&#39;/\.txt$/&#39;</code> 或 <code>&quot;/\.txt$/&quot;</code> 不一样。前者指示 webpack 匹配任何以 <code>.txt</code> 结尾的文件，后者指示 webpack 匹配具有绝对路径 <code>&#39;.txt&#39;</code> 的单个文件; 这可能不符合你的意图。</p></blockquote><ul><li>插件(plugin)</li></ul><p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p><p>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建一个插件实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, use: <span class="string">&#x27;raw-loader&#x27;</span> &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;)],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>html-webpack-plugin</code> 为应用程序生成一个 HTML 文件，并自动注入所有生成的 bundle。</p><ul><li>模式(mode)</li></ul><p>通过选择 development, production 或 none 之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 production。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>浏览器兼容性(browser compatibility)</li></ul><p>webpack 支持所有符合 ES5 标准 的浏览器（不支持 IE8 及以下版本）。webpack 的 import() 和 require.ensure() 需要 Promise。如果你想要支持旧版本浏览器，在使用这些表达式之前，还需要 提前加载 polyfill。</p><ul><li>环境(environment)</li></ul><p>webpack 5 运行于 Node.js v10.13.0+ 的版本.</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;本质上，&lt;code&gt;webpack&lt;/code&gt; 是一个用于现代 &lt;code&gt;JavaScript&lt;/code&gt; 应用程序的 静态模块打包工具。当 &lt;code&gt;webpack&lt;/code&gt; 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 &lt;code&gt;bundle&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 注意：从 v4.0.0 开始，webpack 可以不用再引入一个配置文件来打包项目，然而，它仍然有着 高度可配置性，可以很好满足你的需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;我们为什么要学习webpack&quot;&gt;&lt;a href=&quot;#我们为什么要学习webpack&quot; class=&quot;headerlink&quot; title=&quot;我们为什么要学习webpack&quot;&gt;&lt;/a&gt;我们为什么要学习&lt;a href=&quot;https://webpack.docschina.org/concepts/&quot;&gt;&lt;code&gt;webpack&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;webpack&lt;/code&gt;的主要优势&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;① 模块化开发（import，require）&lt;br&gt;② 预处理（Less，Sass，ES6，TypeScript……）&lt;br&gt;③ 主流框架脚手架支持（Vue，React，Angular）&lt;br&gt;④ 庞大的社区（资源丰富，降低学习成本）&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://faketerrible.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="webpack" scheme="https://faketerrible.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>搞定分类和标签</title>
    <link href="https://faketerrible.github.io/2021/05/23/%E6%90%9E%E5%AE%9A%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE/"/>
    <id>https://faketerrible.github.io/2021/05/23/%E6%90%9E%E5%AE%9A%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE/</id>
    <published>2021-05-23T04:10:49.000Z</published>
    <updated>2021-05-23T04:24:28.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始前的回顾"><a href="#开始前的回顾" class="headerlink" title="开始前的回顾"></a>开始前的回顾</h3><p>作为菜鸟，开始整理自己博客，就碰到了许多问题。一个礼拜以来，虽然一直在记录自己的历程，但是结果却不尽人意。我一开始并不觉得没有分类和标签有什么的，但是，随着自己文章的增多，一直这样是不好的。无奈，开始自己的创建分类和标签之旅。</p><span id="more"></span><h3 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h3><ul><li><strong>创建分类页面</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><ul><li><strong>index.md内容</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2021-05-23 11:42:27</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><ul><li><strong>创建标签页面</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><ul><li><strong>index.md内容</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2021-05-23 11:54:39</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>我开始使用的时候，是缺少<code>layout</code>这个选项的。于是，我的分类和标签页面没有任何内容。</p><p>在加上<code>layout</code>之后，一切解决，完美的呈现了我的文章的分类和标签。</p><h3 id="回顾和反思"><a href="#回顾和反思" class="headerlink" title="回顾和反思"></a>回顾和反思</h3><p>我接触<code>hexo</code>其实很久了，直到最近才开始真的使用，配置了网站的icon等。文章写起来也比一起顺手的多，毕竟接触md文档时间也不短了。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;开始前的回顾&quot;&gt;&lt;a href=&quot;#开始前的回顾&quot; class=&quot;headerlink&quot; title=&quot;开始前的回顾&quot;&gt;&lt;/a&gt;开始前的回顾&lt;/h3&gt;&lt;p&gt;作为菜鸟，开始整理自己博客，就碰到了许多问题。一个礼拜以来，虽然一直在记录自己的历程，但是结果却不尽人意。我一开始并不觉得没有分类和标签有什么的，但是，随着自己文章的增多，一直这样是不好的。无奈，开始自己的创建分类和标签之旅。&lt;/p&gt;</summary>
    
    
    
    <category term="hexo" scheme="https://faketerrible.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://faketerrible.github.io/tags/hexo/"/>
    
    <category term="分类" scheme="https://faketerrible.github.io/tags/%E5%88%86%E7%B1%BB/"/>
    
    <category term="标签" scheme="https://faketerrible.github.io/tags/%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>猿辅导面试查漏补缺</title>
    <link href="https://faketerrible.github.io/2021/05/21/%E7%8C%BF%E8%BE%85%E5%AF%BC%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>https://faketerrible.github.io/2021/05/21/%E7%8C%BF%E8%BE%85%E5%AF%BC%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</id>
    <published>2021-05-21T12:39:14.000Z</published>
    <updated>2021-05-23T04:01:18.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本次回顾"><a href="#本次回顾" class="headerlink" title="本次回顾"></a>本次回顾</h3><p>一开始的自我介绍就相当于水水，面试官看样子也不是能做决定的人。本来以为会是很难的面试题，都是那种普普通通，可能还有一些我没有记住的面试题答案，但终究还是水过去了。没有录音，有些可惜。</p><span id="more"></span><h3 id="记录答得不好的题目"><a href="#记录答得不好的题目" class="headerlink" title="记录答得不好的题目"></a>记录答得不好的题目</h3><ul><li><code>setTimeout/setInterval</code></li></ul><p><code>setTimeout()</code> 是属于 window 的方法，该方法用于在指定的毫秒数后调用函数或计算表达式。</p><p>语法格式可以是以下两种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(要执行的代码，等待的毫秒数)</span><br><span class="line"><span class="built_in">setTimeout</span>(JavaScript 函数，等待的毫秒数)</span><br></pre></td></tr></table></figure><p>既然有开始计数，那么相对应的就要有停止计数，停止计时使用的函数为 <code>clearTimeout()</code>。</p><p><code>setTimeout()</code> 方法可以使到浏览器不断执行一段代码或一个函数 当一个 <code>setTimeout( ) </code>开始了循环的工作, 我们要使它停下来, 可使用 <code>clearTimeout( ) </code>这方法。</p><p><code>clearTimeout()</code> 语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clearTimeout</span>(timeoutID)</span><br></pre></td></tr></table></figure><p><code>setInterval()</code> 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。</p><p><code>setInterval()</code> 方法会不停地调用函数，直到 <code>clearInterval()</code> 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 <code>clearInterval()</code> 方法的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(code,milliseconds);</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>,<span class="title">milliseconds</span>,<span class="title">param1</span>,<span class="title">param2</span>,...)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>code/function</td><td>必需。要调用一个代码串，也可以是一个函数。</td></tr><tr><td>milliseconds</td><td>必须。周期性执行或调用 code/function 之间的时间间隔，以毫秒计。</td></tr><tr><td>param1, param2, .</td><td>可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。</td></tr></tbody></table><ul><li>栈溢出</li></ul><p>程序的有效内存还可以再分为多个区域，每个区域都有不同的作用，比如代码区、全局数据区、堆区、栈区、动态链接库区等。</p><p>栈就是这些内存分区中的一个。</p><p>那么，栈是用来做什么的呢？</p><p>整个内存都是用来存储数据的，栈也不例外。栈用来存储程序的局部数据。</p><p>对于C/C++来说，局部数据是指在函数内部定义的数据，例如在函数内部定义的变量、指针、参数、结构体、数组、对象、引用等，它们都要保存到栈中。</p><p>与之相对应的，在函数外部定义的变量、指针、对象、结构体、数组等都是全局数据，它们要保存到全局数据区。</p><p>而 malloc( )、new、new[ ] 是在程序运行的过程中动态地分配内存，这些内存都位于堆区。</p><p>栈为什么会溢出</p><p>对每个程序来说，栈能使用的内存是有限的，一般是 1M~8M，这在编译时就已经决定了，程序运行期间不能再改变。如果程序使用的栈内存超出最大值，就会发生栈溢出（Stack Overflow）错误，程序就崩溃了。</p><p>这个就像木桶里的水，木桶的容量有限，水满了自然会溢出来。</p><ul><li><code>react</code>相关，<code>hook</code></li></ul><p><code>Hook</code> 是 <code>React 16.8</code> 的新增特性。它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个新的叫做 “count” 的 state 变量</span></span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">        Click me</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React 16.8.0</code> 是第一个支持 <code>Hook</code> 的版本。</p><p><code>Hook</code> 是向下兼容的。</p><p><a href="https://zh-hans.reactjs.org/docs/hooks-overview.html">Hook文档</a></p><ul><li>事件循环</li></ul><p>虽然不是第一次听说时间循环，以为自己也理解了，但是真问起来还是一头雾水。</p><p><strong>事件循环</strong></p><p>1.JavaScript是单线程，非阻塞的</p><p><strong>单线程</strong>：</p><p>JavaScript的主要用途是与用户互动，以及操作DOM。如果它是多线程的会有很多复杂的问题要处理，比如有两个线程同时操作DOM，一个线程删除了当前的DOM节点，一个线程是要操作当前的DOM阶段，最后以哪个线程的操作为准？为了避免这种，所以JS是单线程的。即使H5提出了web worker标准，它有很多限制，受主线程控制，是主线程的子线程。</p><p><strong>非阻塞</strong>：通过 event loop 实现。</p><p>2.浏览器的事件循环</p><blockquote><ul><li>执行栈和事件队列</li><li>宏任务和微任务</li></ul></blockquote><p>3.node环境下的事件循环</p><blockquote><ul><li>和浏览器环境有何不同</li><li>事件循环模型</li><li>宏任务和微任务</li></ul></blockquote><p>4.经典题目分析</p><p>详细情况可访问：<a href="https://segmentfault.com/a/1190000022805523">JavaScript中的Event Loop（事件循环）机制</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;本次回顾&quot;&gt;&lt;a href=&quot;#本次回顾&quot; class=&quot;headerlink&quot; title=&quot;本次回顾&quot;&gt;&lt;/a&gt;本次回顾&lt;/h3&gt;&lt;p&gt;一开始的自我介绍就相当于水水，面试官看样子也不是能做决定的人。本来以为会是很难的面试题，都是那种普普通通，可能还有一些我没有记住的面试题答案，但终究还是水过去了。没有录音，有些可惜。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://faketerrible.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://faketerrible.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="javascript" scheme="https://faketerrible.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>记录错题</title>
    <link href="https://faketerrible.github.io/2021/05/20/%E8%AE%B0%E5%BD%95%E9%94%99%E9%A2%98/"/>
    <id>https://faketerrible.github.io/2021/05/20/%E8%AE%B0%E5%BD%95%E9%94%99%E9%A2%98/</id>
    <published>2021-05-20T14:02:22.000Z</published>
    <updated>2021-05-23T04:00:01.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="偶然的机会碰到了一个小程序"><a href="#偶然的机会碰到了一个小程序" class="headerlink" title="偶然的机会碰到了一个小程序"></a>偶然的机会碰到了一个小程序</h3><p>今天在网上的github浏览内容，突然碰到了一位大神的博客，地址见下面：</p><p><a href="https://muyiy.cn/blog/">木易杨的博客</a></p><span id="more"></span><h3 id="闲来无事打开了小程序"><a href="#闲来无事打开了小程序" class="headerlink" title="闲来无事打开了小程序"></a>闲来无事打开了小程序</h3><p>打开小程序后，我惊喜的发现里面内容多多。不由得想要试试水，没想到真的感受到了自己薄弱的基础。十道题错了四个，还有一些是打开console后敲了一遍才知道答案的。</p><h3 id="记录错题"><a href="#记录错题" class="headerlink" title="记录错题"></a>记录错题</h3><ul><li>将<code>hasName</code>设置为<code>true</code>的方法，前提是不能将<code>true</code>作为参数传递。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> hasName=<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>A !!name<br>B name<br>C new Boolean(name)<br>D name.length</p><p><strong>答案：A</strong></p><p>我选了错误答案C，<code>new Boolean(true)</code>返回一个对象包装器，而不是布尔值本身。<br>使用逻辑非运算符<code>!</code>，将返回一个布尔值。如果<code>name</code>是真实的，那么<code>!name</code>为<code>false</code>，<code>!!name</code>返回<code>true</code>。</p><ul><li>当我们这样做时会发生什么</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bark</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Woof!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bark.animal = <span class="string">&#x27;dog&#x27;</span>;</span><br></pre></td></tr></table></figure><p>A Nothing,this is totally fine!<br>B SyntaxError. You cannot add properties to a function this way.<br>C undefined<br>D ReferenceError</p><p><strong>答案：A</strong></p><p>这道题我并不知道答案，也是云里雾里，在console上实验一番才得知答案。</p><p>在<code>javascript</code>中，原始类型之外的所有东西都是对象。函数是一种特殊类型的对象。该函数是具有属性的对象，此属性是可调用的。</p><ul><li>下列代码输出什么<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Lydia Hallie&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(name.padStart(<span class="number">13</span>))</span><br><span class="line"><span class="built_in">console</span>.log(name.padStart(<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li></ul><p>A “Lydia Hallie”,”Lydia Hallie”<br>B “Lydia Hallie”,”Lydia Hallie”(“[13x whitespace]Lydia Hallie”,”[2x whitespace]Lydia Hallie”)<br>C “Lydia Hallie”,”Lydia Hallie”(“[1x whitespace]Lydia Hallie”,”Lydia Hallie”)<br>D “Lydia Hallie”,”Lyd”</p><p><strong>答案：C</strong></p><p>我错误地选择了D，我认为应该可以匹配到，但是我错的离谱，我对<code>padStart</code>并没有认真学习。</p><p><code>padStart</code>方法，可以在字符串的开头添加填充。传递给此方法的参数是字符串的总长度（包含填充）。字符串<code>Lydia Hallie</code>的长度为12，因此在字符串的开头只会插入1（13-12=1）个空格。如果传递的参数小于字符串的长度，则不会填充。</p><ul><li><code>JavaScript</code>全局执行上下文为你创建了两个东西，全局对象和<code>this</code>关键字</li></ul><p>A 对<br>B 错<br>C 视情况而定</p><p><strong>答案：A</strong></p><p>我就比较迷糊了，我知道this指向window，却不敢确定，于是傻傻地选了C</p><p>基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。</p><ul><li>下列代码输出什么<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> message = <span class="string">&#x27;Sorry, you&#x27;</span>re too young.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &#125;else&#123;</span></span><br><span class="line"><span class="string">        const message = &#x27;</span>Yay! You<span class="string">&#x27;re old enough&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(checkAge(<span class="number">21</span>))</span><br></pre></td></tr></table></figure></li></ul><p>A “Sorry,you’re too young”<br>B “Yay!You’re old enough!”<br>C ReferenceError<br>D undefined</p><p><strong>答案：C</strong></p><p>我错误选择了B，因为我没有考虑const没有变量提升</p><p><code>const</code>和<code>let</code>声明的变量是具有块级作用域的，块是大括号{}之间的任何东西。由于块级作用域，我们无法在声明的块之外引用变量，因此抛出<code>ReferenceError</code>。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;偶然的机会碰到了一个小程序&quot;&gt;&lt;a href=&quot;#偶然的机会碰到了一个小程序&quot; class=&quot;headerlink&quot; title=&quot;偶然的机会碰到了一个小程序&quot;&gt;&lt;/a&gt;偶然的机会碰到了一个小程序&lt;/h3&gt;&lt;p&gt;今天在网上的github浏览内容，突然碰到了一位大神的博客，地址见下面：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://muyiy.cn/blog/&quot;&gt;木易杨的博客&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="习题" scheme="https://faketerrible.github.io/categories/%E4%B9%A0%E9%A2%98/"/>
    
    
    <category term="习题" scheme="https://faketerrible.github.io/tags/%E4%B9%A0%E9%A2%98/"/>
    
    <category term="javascripy" scheme="https://faketerrible.github.io/tags/javascripy/"/>
    
  </entry>
  
  <entry>
    <title>设计模式笔记一</title>
    <link href="https://faketerrible.github.io/2021/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>https://faketerrible.github.io/2021/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0%E4%B8%80/</id>
    <published>2021-05-18T11:41:11.000Z</published>
    <updated>2021-05-23T04:00:43.459Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/pub/reader/119937492">设计模式（java）版</a></p><h3 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h3><p>   设计模式耳听已久，经常在一些讨论中谈及。为了不落于后，不得不啃电子书一本，记录本次笔记。</p><span id="more"></span><h5 id="开始前先说目标"><a href="#开始前先说目标" class="headerlink" title="开始前先说目标"></a>开始前先说目标</h5><ul><li><p>了解设计模式的概念</p></li><li><p>了解设计模式的历史</p></li><li><p>理解设计模式的要素</p></li><li><p>掌握设计模式的分类</p></li></ul><h5 id="1-1-设计模式的概念"><a href="#1-1-设计模式的概念" class="headerlink" title="1.1 设计模式的概念"></a>1.1 设计模式的概念</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式（Design Pattern）是一套被反复使用、多数人知晓、经过分类编目的优秀代码设计经验的总结。使用设计模式是为了重用代码、使代码更易理解并保证代码的可靠性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;框架通常定义了应用体系的整体结构类和对象的关系等设计参数，以便具体应用实现者能集中精力于应用本身的特定细节。框架主要记录软件应用中共同的设计决策，强调设计复用，因此成熟的框架设计中必然要使用设计模式，如果熟悉这些设计模式将有助于对框架结构的理解，从而能够迅速掌握框架的结构。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 设计模式贯彻的原理是：面向接口编程，而不是面向实现。其目标原则是：降低耦合，增强灵活性。</p><h5 id="1-2-设计模式简史"><a href="#1-2-设计模式简史" class="headerlink" title="1.2 设计模式简史"></a>1.2 设计模式简史</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式的研究起源于建筑工程设计大师 Christopher Alexander 的关于城市规划和建筑设计的著作。尽管他的著作是针对城市规划和建筑设计的，但是其观点实际上适用于所有工程设计领域，包括软件开发设计领域。Alexander 在其著作中指出，使用现在的设计方法所设计出的建筑物，不能满足所有工程设计的基本目的：改善人类的条件。Alexander 想要发明的建筑结构，是能使人类在舒适和生活质量上受惠的建筑结构。他得出的结论是，设计师必须不断努力，以创造出更加适合所有住户、用户和他们的社区的结构，从而满足他们的需要。同样软件开发中的设计模式也是不断进行研究、创新，以更加适合软件工程的各个方面。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计模式在软件行业中的应用可以追溯到 1987 年。Ward Cunningham 和 Kent Beck 在一起用 Smalltalk 做设计用户界面的工作，他们决定使用 Alexander 的理论发展出一个有五个模式的语言来指导 Smalltalk 的新手，因此他们写了一篇「Using Pattern Languages for Object-Oriented Programs（使用模式语言做面向对象的程序）」的论文。此后不久，James O. Coplien 开始搜集 C++ 语言的成例（成例也可认为是一种设计模式，更偏重于编码技巧），这些 C++ 成例发表在 1991 年出版的《Advanced C++ Programming Styles and Idioms（高级 C++ 编程风格和成例）》一书中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1990 年到 1992 年，Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四个人（常被称为 Gang of Four、GoF 或「四人帮」，如图 1-1 所示），开始了搜集模式的工作。1993 年 8 月，Kent Beck 和 Grady Booch 主持了在美国科罗拉多的山区度假村召开的第一次关于模式的会议，模式研究的主要人物都参加了这次会议，包括 James O. Coplien、Doug Lea、Desmond D’Souze、Norm Kerth、Wolfgang Pree 等。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1995 年 GoF 的「Design Patterns: Elements of Reusable Object-Oriented Software」（《设计模式：可复用面向对象软件的基础》）出版。该书第一次将设计模式提升到理论高度，并将之规范化，同时提出了 23 种基本设计模式。此书发表之后，带动了设计模式的研究热潮，被确定为模式结构的数目也呈爆炸性增长。时至今日，在可复用面向对象软件的发展过程中，新的设计模式仍然不断出现。</p><h5 id="1-3-设计模式要素"><a href="#1-3-设计模式要素" class="headerlink" title="1.3 设计模式要素"></a>1.3 设计模式要素</h5><p><strong>设计模式应当包含以下几个要素</strong></p><ul><li>模式名称（pattern name）</li></ul><p>设计模式的名称简洁地描述了设计模式的问题、解决方案和效果。一个模式必须有一个有意义的、简短而准确的名字。好的模式名称便于设计人员之间交流思想，进行抽象讨论及研究设计结果。</p><ul><li>问题（problem）</li></ul><p>描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等，也可能描述了导致不灵活设计的类或对象结构。</p><ul><li>环境或初始环境（context 或 initial context）</li></ul><p>解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</p><ul><li>效果（consequences）</li></ul><p>描述了模式应用的效果及使用模式应权衡的问题。效果用来描述设计模式的利弊，它往往是衡量模式是否可用的重要因素，对于评价设计选择和理解使用模式的代价及好处具有重要意义。</p><ul><li>举例（examples）</li></ul><p>从熟知系统里取出来的、有视觉效果的，或以比喻方式表达的例子，更易于使用者理解。</p><ul><li>末态环境（resulting context）</li></ul><p>末态环境包括模式带来的好结果和坏结果，以及新状态中含有的其他问题和可能涉及的其他有关系的模式。末态环境是模式的末态条件和可能有的副作用。</p><ul><li>推理（rationale）</li></ul><p>推理解释本模式的步骤、规则，以及此模式作为一个整体是如何以特定的方式解决模式的。推理让使用者知道模式是如何工作的，为什么可以工作，以及使用此模式的优点是什么。</p><ul><li>其他有关模式（related pattern）</li></ul><p>描述在现有的系统中此模式与其他模式的静态和动态的关系。相关模式的初始环境和末态环境经常是相容的，这些模式有可能是本模式的前任模式，即应用了这些模式可以给出本模式的初始环境，也有可能是本模式的继任模式，即本模式的应用给出这些模式的初始环境。</p><ul><li>已知的应用（known uses）</li></ul><p>已知的应用是在已有的系统模式中出现和应用的例子，有助于证明此模式确实是对一个重复发生的问题可行的解答。</p><h5 id="1-4-设计模式分类"><a href="#1-4-设计模式分类" class="headerlink" title="1.4 设计模式分类"></a>1.4 设计模式分类</h5><ul><li>创建型</li></ul><p><strong>所有的创建型模式都有两个主要功能：</strong></p><p>■ 将系统所使用的具体类的信息封装起来；</p><p>■ 隐藏类的实例是如何被创建和组织的。外界对于这些对象只知道它们共同的接口，而不清楚其具体的实现细节。</p><p><strong>常见的创建型设计模式有下列几种。</strong></p><p>■ 单例模式（Singleton Pattern）：一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p>■ 工厂方法模式（Factory Pattern）：在工厂方法模式中，工厂类成为了抽象类，实际的创建工作将由其具体子类来完成。工厂方法的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中去，强调的是「单个对象」的变化。</p><p>■ 抽象工厂模式（Abstract Factory）：抽象工厂是所有工厂模式中最为抽象和最具有一般性的一种形态。抽象工厂可以向客户提供一个接口，使得客户可以在不必指定产品具体类型的情况下，创建多个产品族中的产品对象，强调的是「系列对象」的变化。</p><p>■ 建造者模式（Builder Pattern）：把构造对象实例的逻辑移到了类的外部，在类的外部定义了该类的构造逻辑。它把一个复杂对象的构造过程从对象的表示中分离出来，其直接效果是将一个复杂的对象简化为一个比较简单的目标对象，强调的是产品的构造过程。</p><p>■ 原型模式（Prototype Pattern）：原型模式和工厂模式一样，同样对客户隐藏了对象创建工作，但与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过复制一个现有对象生成新对象。</p><ul><li>结构型</li></ul><p><strong>常见的结构型设计模式有以下几种。</strong></p><p>■ 代理模式（Proxy）：为其他对象提供一种代理以控制对该对象的访问。</p><p>■ 装饰模式（Decorator）：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p><p>■ 适配器模式（Adapter）：将一个类的接口变换成客户端所期待的另一接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><p>■ 组合模式（Composite）：也叫合成模式，将对象组合成树形结构以表示「部分—整体」的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><p>■ 桥梁模式（Bridge）：也叫桥接模式，将抽象和实现解耦，使得两者可以独立变化。</p><p>■ 外观模式（Facade）：也叫门面模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行，外观模式提供一个高层次的接口，使得子系统更易于使用。</p><p>■ 享元模式（Flyweight）：是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象。</p><ul><li>行为型</li></ul><p><strong>常见的行为型设计模式有以下几种。</strong></p><p>■ 模板方法模式（Template Method）：定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>■ 命令模式（Command）：是一种高内聚的模式，将一个请求封装成一个对象，从而使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p><p>■ 责任链模式（Chain of Responsibility）：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p><p>■ 策略模式（Strategy）：也叫政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p><p>■ 迭代器模式（Iterator）：提供一种方法访问一个容器对象中的各个元素，而又不需要暴露该对象的内部细节。</p><p>■ 中介者模式（Mediator）：用一个中介对象封装一系列的对象交互，中介者使各对象不需要显式地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>■ 观察者模式（Observer）：也叫发布订阅模式，定义对象间的一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p><p>■ 备忘录模式（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p>■ 访问者模式（Visitor）：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p><p>■ 状态模式（State）：当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类型，状态模式的核心是封装，状态的变更引起行为的变更。</p><p>■ 解释器模式（Interpreter）：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该文法表示来解释语言中的句子。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/pub/reader/119937492&quot;&gt;设计模式（java）版&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;设计模式概述&quot;&gt;&lt;a href=&quot;#设计模式概述&quot; class=&quot;headerlink&quot; title=&quot;设计模式概述&quot;&gt;&lt;/a&gt;设计模式概述&lt;/h3&gt;&lt;p&gt;   设计模式耳听已久，经常在一些讨论中谈及。为了不落于后，不得不啃电子书一本，记录本次笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://faketerrible.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://faketerrible.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="java" scheme="https://faketerrible.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>前端学习</title>
    <link href="https://faketerrible.github.io/2021/05/18/javascript-%E5%AD%A6%E4%B9%A0/"/>
    <id>https://faketerrible.github.io/2021/05/18/javascript-%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-05-18T08:57:00.000Z</published>
    <updated>2021-05-23T06:21:43.802Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端学习地址"><a href="#前端学习地址" class="headerlink" title="前端学习地址"></a>前端学习地址</h3><p><a href="https://es6.ruanyifeng.com/">ES6入门教程</a></p><p><a href="https://zh-hans.reactjs.org/">react</a></p><p><a href="https://v3.cn.vuejs.org/">vue</a></p><p><a href="http://nodejs.cn/learn">Node</a></p><p>看一遍或者学一遍，基本可以入门，掌握前端的基本操作和框架。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前端学习地址&quot;&gt;&lt;a href=&quot;#前端学习地址&quot; class=&quot;headerlink&quot; title=&quot;前端学习地址&quot;&gt;&lt;/a&gt;前端学习地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://es6.ruanyifeng.com/&quot;&gt;ES6入门教程&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="前端" scheme="https://faketerrible.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="https://faketerrible.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://faketerrible.github.io/2021/05/18/hello-world/"/>
    <id>https://faketerrible.github.io/2021/05/18/hello-world/</id>
    <published>2021-05-18T08:22:20.610Z</published>
    <updated>2021-05-18T08:22:20.610Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
